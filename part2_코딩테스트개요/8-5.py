#p.217
#1로 만들기. 전형적인 다이나믹 프로그래밍

#정수 입력받음
x = int(input())

#계산된 결과 저장을 위한 dp테이블 초기화
#정수의 범위 1<=x<=30000인데 
#각 정수별로 계산이 몇 번 이뤄지는지 그 횟수가 테이블에 저장된다.
#그래서 더 큰 정수를 쪼갰을때 아래의 정수가 이미 데이터에 저장되어 있으면 그걸 갖다 쓴다.
d = [0]*30001

#다이나믹 프로그래밍 진행
#반복문. 보텀업방식 - 초기값 2부터 입력값 x가 될때까지 하나씩 계산해가며 테이블에 저장한다.
#1일때는 계산횟수 0이므로 2부터 시작
for i in range(2, x+1):
	#현재의 수에서 1을 빼는 경우
	#그 이전 정수에서 한번 계산 추가된거이므로 +1
	d[i] = d[i-1] + 1

	#현재의 수가 2로 나누어 떨어지는 경우
	#2로 나눈 몫 d[i//2] ==> 여기에 해당 값에서 이미 계산 몇번 되어잇는지가 테이블에 저장되어 있으므로 여기에 2로나누는 계산 +1을 한다.
	#위에 1뺀거랑 비고했을때 더 적게 계산하는것을 선택한다.
	if i % 2 == 0:
		d[i] = min(d[i], d[i//2] +1) 

	#현재의 수가 3로 나누어 떨어지는 경우
	if i % 3 == 0:
		d[i] = min(d[i], d[i//3] +1) 

	#현재의 수가 5로 나누어 떨어지는 경우
	if i % 5 == 0:
		d[i] = min(d[i], d[i//5] +1) 

print(d[x])






